#version 450

layout (local_size_x = 32) in;

struct RenderableInfo
{
    uint meshID;
    uint objID;
};

struct DrawCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

struct DrawInfo
{
    uint objID;
};


// IN / READONLY

layout(set=0, binding=0) buffer readonly ssbo_0 
{
    // size      = max # of loaded renderables
    // populated = packed
    // init      = state after cull
    RenderableInfo data[];
} ssbo_renderableInfos;

layout(set=0, binding=1) buffer readonly ssbo_1
{
    // size      = max # of loaded meshes
    // populated = sparse
    // init      = state after cull
    int data[];
} ssbo_meshToCommandMapping;


// WRITE

layout(set=0, binding=2) buffer ssbo_2
{
    // size = # of loaded meshes
    // init = { 0, 0, 0, 0, 0, ... }
    uint data[];  
}  ssbo_meshInstanceCount; 

layout(set=0, binding=3) buffer ssbo_3
{
    // init = 0
    uint data;
}  ssbo_firstInstanceCount;

layout(set=0, binding=4) buffer ssbo_4
{
    DrawCommand data[];
} ssbo_drawCommands;

layout(set=0, binding=5) buffer ssbo_5
{
    // size = max # of loaded renderables
    DrawInfo data[];
} ssbo_drawInfos;


void populateRenderableInfo(in uint innvocID, inout uint meshID, inout uint objID)
{
    RenderableInfo info = ssbo_renderableInfos.data[innvocID];
    meshID = info.meshID;
    objID  = info.objID;
}


void main()
{
    if (gl_GlobalInvocationID.x >= 3)
        return;


    uint meshID = 0;
    uint objID  = 0;
    populateRenderableInfo(gl_GlobalInvocationID.x, meshID, objID);

    uint instance = atomicAdd(ssbo_meshInstanceCount.data[meshID], 1);

    if (instance == 0)
    {
        int commandID = ssbo_meshToCommandMapping.data[meshID];

        uint meshInstanceCount = ssbo_drawCommands.data[commandID].instanceCount;

        // I need to set the first instance in the draw command
        uint firstInstance = atomicAdd(ssbo_firstInstanceCount.data, meshInstanceCount);

        ssbo_drawCommands.data[commandID].firstInstance = firstInstance;
    }

    // memory barrier - need for first index to be set before writing to drawID array
    groupMemoryBarrier();
    // bufferMemoryBarrier(); // shouldnt need this

    int commandID = ssbo_meshToCommandMapping.data[meshID];
    uint firstInstance = ssbo_drawCommands.data[commandID].firstInstance;

    // write to draw id array

    ssbo_drawInfos.data[firstInstance + instance].objID = objID;
}

// void main()
// {
//     uint renderableID = gl_GlobalInvocationID.x;
//     RenderableInfo renderableInfo = visibleRenderables.data[renderableID];

//     if (atomicCompSwap(meshActive.data[renderableInfo.meshID], 0, 1) != 0)
//     {
//         DrawCommand drawCmd = drawCommands.data[renderableInfo.meshID];
//         uint firstInstance = atomicAdd(instanceCount.data, drawCmd.instanceCount);
//         drawCommands.data[renderableInfo.meshID].firstInstance = firstInstance;
//     }
// }

// DISPATCH
// # of visible renderables

// IN
// Buffer - uint32_t (init to 0) (used for counting # of instances processed)
// Buffer - IndirectDrawCommand per mesh, with visible instanceCount
// Buffer - RenderableInfo per visible renderable

// OUT
// Buffer - IndirectDrawCommand per mesh, with visible instanceCount + firstInstance
// Buffer - # of visible meshes
// Buffer - # of visible renderables
// Buffer - RenderableInfo per visible renderable