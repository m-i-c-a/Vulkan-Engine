#version 450

layout (local_size_x = 32) in;

struct RenderableInfo
{
    uint meshID;
    uint objectID;
};

struct DrawCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

// Buffer pool - A
layout(set=0, binding=0) buffer readonly ssbo_0 
{
    RenderableInfo data[];
} loadedRenderables;

 // GPU only - B
layout(set=0, binding=1) buffer ssbo_1 
{
    RenderableInfo data[];
} visibleRenderables;

// GPU only - C
layout(set=0, binding=2) buffer ssbo_2
{
    uint data;
} visibleCount;

// Buffer pool - D
layout(set=0, binding=3) buffer ssbo_3
{
    DrawCommand data[];
}  drawCommands; 

layout(push_constant) uniform pc
{
    uint loadedRenderableCount;
} pushConst;

bool isVisible()
{
    return true;
}

void main()
{
    if (gl_GlobalInvocationID.x >= pushConst.loadedRenderableCount)
        return;

    uint loadedID = gl_GlobalInvocationID.x;
    RenderableInfo loadedRenderableInfo = loadedRenderables.data[loadedID];

    if (isVisible())
    {
        uint visibleID = atomicAdd(visibleCount.data, 1);
        visibleRenderables.data[visibleID] = loadedRenderableInfo;
        uint instance = atomicAdd(drawCommands.data[loadedRenderableInfo.meshID].instanceCount, 1);
        if (instance == 0)
        {
            // renderableCount++
        }
    }
}

// DISPATCH
// # of loaded renderables

// IN
// Buffer - RenderableInfo per loaded renderable

// OUT
// Buffer - # of visible meshes
// Buffer - # of visible renderables
// Buffer - IndirectDrawCommand per mesh, with visible instance count
// Buffer - RenderableInfo per visible renderable